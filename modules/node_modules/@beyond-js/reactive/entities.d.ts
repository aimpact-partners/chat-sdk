/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@beyond-js/reactive/model';
import * as __beyond_dep_ns_1 from 'dexie';
import * as __beyond_dep_ns_2 from '@beyond-js/kernel/core';
import * as __beyond_dep_ns_3 from '@beyond-js/events/events';
// adapter\default.ts
declare namespace ns_0 {
  import IResponseAdapter = ns_2.IResponseAdapter;
  export class DefaultAdapter implements IResponseAdapter {
    toClient(data: any): Promise<any>;
    fromRemote(data: any): Promise<any>;
    fromRemoteList(data: any): Promise<any>;
  }
}


// adapter\index.ts
declare namespace ns_1 {
  import DefaultAdapter = ns_0.DefaultAdapter;
  import LegacyAdapter = ns_3.LegacyAdapter;
  interface IResponseAdapter {
    toClient: (data: any) => any;
    fromRemote: (data: any) => any;
    fromRemoteList?: (data: any) => any;
  }
  export type TCustomAdapter = new () => IResponseAdapter;
  export interface IConfig {
    adapter: 'default' | 'legacy' | TCustomAdapter;
  }
  export type TAdapters = 'default' | 'legacy' | TCustomAdapter;
  export class ResponseAdapter {
    static get(parent: any, adapters?: IConfig['adapter']): DefaultAdapter | LegacyAdapter;
  }
  export {};
}


// adapter\interface.ts
declare namespace ns_2 {
  export interface IResponseAdapter {
    toClient: (data?: any) => any;
    fromRemote: (data: any) => any;
    fromRemoteList?: (data: any) => any;
  }
}


// adapter\legacy.ts
declare namespace ns_3 {
  import IResponseAdapter = ns_2.IResponseAdapter;
  interface Iresponse {
    status?: boolean;
    error?: any;
    data?: any;
  }
  type ErrorApi = {
    message?: string;
    text?: string;
    id: string | number;
  };
  type ErrorMessage = string;
  interface IParams {
    status?: boolean;
    error?: ErrorApi | ErrorMessage;
    data?: any;
    message?: string;
  }
  export class LegacyAdapter implements IResponseAdapter {
    #private;
    constructor(parent: any);
    toClient(response?: IParams): Iresponse;
    fromRemote(response: IParams): IParams;
    fromRemoteList(data: any): Promise<any>;
  }
  export {};
}


// cache\index.ts
declare namespace ns_4 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  export class CacheManager extends ReactiveModel<CacheManager> {}
}


// collection\index.ts
declare namespace ns_5 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import CollectionLocalProvider = ns_9.CollectionLocalProvider;
  import IProvider = ns_15.IProvider;
  import ICollectionSpecs = ns_7.ICollectionSpecs;
  import IResponseAdapter = ns_2.IResponseAdapter;
  import Item = ns_16.Item;
  export class Collection extends ReactiveModel<Collection> {
    #private;
    triggerEvent: (event?: string) => void;
    storeName: string;
    trigger: (event?: string) => void;
    reactiveProps: <T>(props: Array<keyof T>) => void;
    landed: boolean;
    db: string;
    item: typeof Item;
    protected localdb: boolean;
    get elements(): Map<any, any>;
    get items(): Array<any | undefined>;
    get isOnline(): boolean;
    set items(value: Array<any | undefined>);
    counters: any;
    total: number;
    next: number | undefined;
    get localProvider(): CollectionLocalProvider;
    get provider(): IProvider;
    protected sortBy: string;
    protected orderBy: string;
    protected sortDirection: 'asc' | 'desc';
    get responseAdapter(): IResponseAdapter;
    constructor(specs: ICollectionSpecs);
    protected init(): void;
    setOffline: (value: any) => void;
    protected setItems(values: any): void;
    store(): Promise<Table>;
    set(data: any): Promise<void>;
    delete(ids: any): Promise<void>;
    load(args?: any): Promise<any>;
    localLoad(args: any): Promise<any>;
    filter: (args?: any) => any;
    save: (args?: any, init?: any) => Promise<boolean | void>;
    publish: (args?: any) => Promise<unknown>;
    setEntries(entries: any): Promise<Item<any>[]>;
  }
}


// collection\interfaces\children-constructor-props.ts
declare namespace ns_6 {
  import Collection = ns_5.Collection;
  export interface IInternalCollectionParams {
    parent: Collection;
    localdb: boolean;
    bridge: {
      get: (property: string) => any;
      set: (property: string, value: any) => void;
    };
  }
}


// collection\interfaces\collection.ts
declare namespace ns_7 {
  import Item = ns_16.Item;
  import IProviderConstructor = ns_15.IProviderConstructor;
  import TAdapters = ns_1.TAdapters;
  export type TItemConstructor<T extends object = any> = new (args?: {
    id?: any;
  }) => Item<T>;
  export interface ICollection {
    items: object[];
    item: TItemConstructor;
    next: number | undefined;
    provider: TItemConstructor;
  }
  export interface ICollectionSpecs {
    provider?: IProviderConstructor;
    storeName?: string;
    db?: string;
    localdb?: boolean;
    item: TItemConstructor<any>;
    adapter?: TAdapters;
  }
}


// collection\load.ts
declare namespace ns_8 {
  import Collection = ns_5.Collection;
  import Item = ns_16.Item;
  import IInternalCollectionParams = ns_6.IInternalCollectionParams;
  import IItem = ns_18.IItem;
  export class CollectionLoadManager {
    #private;
    filter: any;
    get parent(): Collection;
    protected remoteData: any[];
    constructor({
      parent,
      bridge,
      localdb
    }: IInternalCollectionParams);
    init(): void;
    localLoad: (params?: any) => Promise<any>;
    load: (params?: any) => Promise<any>;
    /**
     *
     * @param data
     * @returns
     */
    processRemoteEntries(data: {
      [key: string]: any;
    }): Promise<Item<IItem>[]>;
    /**
     *
     * This method is used to process the "local entries"
     *
     * @param entries
     * @param updateLocalItems
     * @returns
     */
    processEntries: (entries: Item<any>[], updateLocalItems?: boolean) => Promise<Item<any>[]>;
    remoteLoad: (params: any) => Promise<any>;
  }
}


// collection\local-provider\index.ts
declare namespace ns_9 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import Table = __beyond_dep_ns_1.Table;
  import Collection = ns_5.Collection;
  interface IItemValues {
    [key: string]: any;
    offline: number;
    instanceId: string;
  }
  export class CollectionLocalProvider extends ReactiveModel<CollectionLocalProvider> {
    #private;
    get store(): Table<any, IndexableType>;
    get apply(): boolean;
    get active(): boolean;
    get items(): any[];
    get isOnline(): boolean;
    constructor(parent: Collection, bridge: {
      get: (property: string) => any;
      set: (property: string, value: any) => void;
    });
    setOffline(value: boolean): void;
    init: () => Promise<void>;
    private handleConnection;
    upsert(data: IItemValues[], originalData: any[]): Promise<void>;
    softDelete(ids: any): Promise<true | {
      status: boolean;
      data: any[];
      error?: undefined;
    } | {
      status: boolean;
      error: any;
      data?: undefined;
    }>;
    deleteItems(ids: any): Promise<void>;
    save: (data: any) => Promise<any>;
    saveAll: (items: any, storeName: any) => Promise<{
      status: boolean;
      failed?: undefined;
    } | {
      status: boolean;
      failed: any;
    }>;
    load: (params: any) => Promise<any>;
  }
  export {};
}


// collection\local-provider\loader.ts
declare namespace ns_10 {
  import CollectionLocalProvider = ns_9.CollectionLocalProvider;
  export class LocalProviderLoader {
    #private;
    constructor(parent: CollectionLocalProvider, parentPrivateProps: any);
    load(params: Record<string, any>): Promise<any>;
    where: (params: any, limit: any) => () => Promise<any[]>;
    customFilter: (callback: Function) => CollectionLocalProvider;
  }
}


// collection\local-provider\saver.ts
declare namespace ns_11 {
  import CollectionLocalProvider = ns_9.CollectionLocalProvider;
  export class LocalProviderSaver {
    #private;
    constructor(parent: CollectionLocalProvider, parentBridge: any);
    save(data: {
      [key: string]: any;
    }): Promise<any>;
    /**
     * Saves a collection of items to the specified store in batches.
     *
     * @param {Array} items - The items to be saved.
     * @param {string} storeName - The name of the store where items will be saved.
     * @returns {Promise<{ status: boolean, failed?: Array }>} An object containing the status of the operation.
     * If the status is true, all batches have been saved successfully. If the status is false, the failed property contains an array with information about failed batches.
     * Each failed batch object has a status, a reason (if the batch is rejected), an index (the original batch position), and data (the failed batch data).
     * @throws Will throw an error if there's an issue with the Promise.allSettled() call itself.
     */
    saveAll(items: any, storeName: string): Promise<{
      status: boolean;
      failed?: undefined;
    } | {
      status: boolean;
      failed: any;
    }>;
  }
}


// collection\publish.ts
declare namespace ns_12 {
  import Collection = ns_5.Collection;
  export class CollectionSaveManager {
    #private;
    constructor(parent: Collection, bridge: {
      get: (property: string) => any;
      set: (property: string, value: any) => void;
    });
    init(): void;
    /**
     *
     * @param data elements to save
     * @param init  lets define if the elements to save will work as a list of elements in the collection when is instanced
     * @returns
     */
    save: (data?: any[], init?: boolean) => Promise<boolean | void>;
    publish: (data?: any[]) => Promise<unknown>;
  }
}


// example\collection.ts
declare namespace ns_13 {
  export {};
}


// example\index.ts
declare namespace ns_14 {
  import Item = ns_16.Item;
  import IItem = ns_18.IItem;
  interface IBook extends IItem {
    name?: string;
    password: string;
    lastnames: string;
    [props: string]: any;
  }
  export class Book extends Item<IBook> {
    protected properties: string[];
    constructor({
      id
    }?: {
      id?: any;
    });
  }
  export {};
}


// interfaces\provider.ts
declare namespace ns_15 {
  export interface IResponse {
    status: boolean;
    data?: object;
    error?: string | string[];
  }
  export type ModelId = string | number;
  export interface IProvider {
    publish?(properties: Record<string, any>): Promise<IResponse>;
    load?: (data: object) => Promise<any>;
    list?: (params: any) => Promise<any>;
    delete?: (id: ModelId) => Promise<any>;
    bulkSave?: (data: object[]) => Promise<any>;
    deleteItems?: (id: ModelId) => Promise<any>;
  }
  export interface IItemProvider<T> {
    publish?: (properties: Record<string, any>) => Promise<IResponse>;
    load?: (data: object) => Promise<IResponse>;
    delete?: (id: ModelId) => Promise<IResponse>;
  }
  export interface IProviderConstructor {
    new (specs?: any): IProvider;
  }
}


// item\index.ts
declare namespace ns_16 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import LocalProvider = ns_20.LocalProvider;
  import PendingPromise = __beyond_dep_ns_2.PendingPromise;
  import IItem = ns_18.IItem;
  import IItemConfig = ns_17.IItemConfig;
  import IResponseAdapter = ns_2.IResponseAdapter;
  import ListenerFunction = __beyond_dep_ns_3.ListenerFunction;
  import IItemProvider = ns_15.IItemProvider;
  export class Item<T> extends ReactiveModel<IItem> {
    #private;
    trigger: (event?: string) => void;
    triggerEvent: (event?: string) => void;
    getProperties: () => any;
    landed: boolean;
    on: (event: string, listener: ListenerFunction, priority?: number) => this;
    id: string | number;
    localUpdate: (data: any) => Promise<any>;
    protected localdb: boolean;
    protected storeName: string;
    protected db: string;
    localFields: any[];
    localProvider: LocalProvider;
    protected unique: Array<string>;
    get skeleton(): string[];
    private __get;
    get provider(): IItemProvider<IItem>;
    get isDeleted(): boolean;
    get store(): Table;
    get isOnline(): boolean;
    get __instanceId(): string;
    get isReady(): true | PendingPromise<boolean>;
    /**
     * Defines if the item was found in the local database
     */
    found: boolean;
    get responseAdapter(): IResponseAdapter;
    constructor(config?: IItemConfig);
    protected initialise(): Promise<void>;
    /**
     * Validates if the object is ready to be used
     *
     * Is implemented internally by methods such as publish or load to avoid errors in cases
     * where could it be called before the object is ready.
     *
     * @returns {Promise<boolean>} A promise that resolves when the object is ready
     */
    protected checkReady(): true | PendingPromise<boolean>;
    protected init(config: IItemConfig): Promise<boolean>;
    setOffline: (value: any) => void;
    /**
     * Set the data of the object
     *
     * @param data The data to set
     * @param init If true, the data will be stored in the local database
     */
    set(data: any, init?: boolean): Promise<void>;
    /**
     * @deprecated Please use getProperties instead
     * @see ReactiveModel.properties
     */
    getValues(): {};
    getPropertyNames(): string[];
    save(data?: any): Promise<any>;
    sync(): void;
    forceSync(): void;
    publish(data?: any): Promise<any>;
    load(params?: any): Promise<any>;
    delete(): Promise<boolean>;
  }
}


// item\interfaces\config.ts
declare namespace ns_17 {
  import TAdapters = ns_1.TAdapters;
  import IProvider = ns_15.IProvider;
  export interface IItemConfig {
    storeName?: string;
    db?: string;
    id?: string | number;
    localdb?: boolean;
    properties?: string[];
    provider?: new (item?: any) => IProvider;
    adapter?: TAdapters;
  }
}


// item\interfaces\item.ts
declare namespace ns_18 {
  export interface IItem {
    id: string | number;
    provider?: any;
    skeleton?: Array<string>;
    isUnpublished: boolean;
    properties: string[];
    load: Function;
    unique: Array<string>;
    save(): Promise<{
      status: boolean;
      error?: string;
    }>;
    publish(): Promise<{
      status: boolean;
      error?: string;
    }>;
    localUpdate(data: any, broadcastUpdate?: boolean): Promise<{
      status: boolean;
      error?: string;
    }>;
    sync(): Promise<{
      status: boolean;
      error?: string;
    }>;
  }
}


// item\load.ts
declare namespace ns_19 {
  export class ItemLoadManager<T> {
    #private;
    ready: boolean;
    constructor({
      parent,
      bridge,
      localdb
    }: {
      parent: any;
      bridge: any;
      localdb: any;
    });
    init: () => void;
    /**
     * Load the data from the provider and save it in the local database
     *
     * The method returns the data from the provider, if the provider is not set, it returns undefined, if
     * the provider method returns more data than the properties defined in the object, the data will be
     * available in the response.data object returned by the method.
     *
     * @param id
     * @returns
     */
    load: (params: any) => Promise<any>;
    remoteLoad: (params: any) => Promise<any>;
  }
}


// item\local-provider.ts
declare namespace ns_20 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import Table = __beyond_dep_ns_1.Table;
  import Registry = ns_25.Registry;
  export class LocalProvider extends ReactiveModel<any> {
    #private;
    get store(): Table<any, any>;
    __instanceId: string;
    get originalData(): {};
    get isOnline(): boolean;
    get localdb(): any;
    get registry(): Registry;
    __moment: number;
    constructor({
      parent,
      bridge,
      localdb
    }: {
      parent: any;
      bridge: any;
      localdb: any;
    });
    setOffline(value: any): void;
    init: (id?: string | number | undefined) => Promise<any>;
    deepCompare(obj1: any, obj2: any): boolean;
    isObject(object: any): boolean;
    load(params?: any): Promise<any>;
    save(data: any): Promise<this | {
      error: string;
      fields: any[];
    }>;
    validateUniqueFields(data: any): Promise<any[]>;
    delete: () => Promise<boolean>;
    deleteRegistry: (identifier: any) => Promise<boolean>;
    isPlainObject(obj: any): boolean;
  }
}


// item\save.ts
declare namespace ns_21 {
  export class ItemSaveManager {
    #private;
    constructor({
      parent,
      bridge,
      localdb
    }: {
      parent: any;
      bridge: any;
      localdb: any;
    });
    init(): void;
    save: (data?: any) => Promise<any>;
    publish: (data?: any) => Promise<any>;
    sync: () => void;
    forceSync(): void;
    localUpdate: (data?: any) => Promise<any>;
  }
}


// providers\collection.ts
declare namespace ns_22 {
  export abstract class CollectionProvider {
    list(specs: object): void;
    publish(props: object): void;
    load(specs: object): void;
  }
}


// providers\item.ts
declare namespace ns_23 {
  export abstract class ItemProvider {
    delete(id: string): void;
    publish(props: object): void;
    load(specs: object): void;
  }
}


// registry\factory.ts
declare namespace ns_24 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import Registry = ns_25.Registry;
  interface IRecords {
    stores: Map<string, Map<string, Registry>>;
  }
  /**
   *
   */
  export class RegistryFactory extends ReactiveModel<IRecords> {
    #private;
    constructor(dbName: any, localdb?: boolean);
    init(): Promise<any>;
    /**
     * Loop a list of items and if they don't exist in memorey, create the registry and add it to the store.
     * @param storeName
     * @param items
     */
    registerList(storeName: any, items: any): void;
    /**
     * Validates if the specified item exists in the specified store.
     *
     *  This method is used by the LocalProvider to know if a item was already loaded or not.
     *  If the item is not loaded, the LocalProvider will load it from the database and pass the data to the Factory
     *  to create the registry in memory
     * @param storeName store name
     * @param id Id of the item to validate if exists or is loaded
     * @returns
     */
    hasItem(storeName: any, id: any): any;
    getItem(storeName: any, id: any): any;
    create(storeName: any, data: any): Registry;
    get(storeName: string, id?: any): Promise<any>;
    has(storeName: any, id: any): Promise<boolean>;
    /**
     * Returns a RegistryFactory instance for the specified database name.
     *
     * @param dbName IndexedDB database name
     * @returns
     */
    static get(dbName: any, localdb?: any): RegistryFactory;
  }
  export {};
}


// registry\index.ts
declare namespace ns_25 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  interface IRegistry {
    values?: object;
    id?: string | number;
    __instanceId?: string;
  }
  export class Registry extends ReactiveModel<IRegistry> {
    #private;
    get values(): any;
    __instanceId: string;
    get isNew(): boolean;
    set isNew(value: boolean);
    get isDeleted(): any;
    set isDeleted(value: any);
    constructor(store: any, data?: IRegistry);
    setValues: (data: any) => boolean;
    getValues(): any;
  }
  export {};
}


// registry\store.ts
declare namespace ns_26 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  interface IStoreRecords {}
  export class StoreRecords extends ReactiveModel<IStoreRecords> {}
  export {};
}


export import TCustomAdapter = ns_1.TCustomAdapter;
export import IConfig = ns_1.IConfig;
export import IResponseAdapter = ns_2.IResponseAdapter;
export import Collection = ns_5.Collection;
export import CollectionLocalProvider = ns_9.CollectionLocalProvider;
export import Book = ns_14.Book;
export import IProvider = ns_15.IProvider;
export import Item = ns_16.Item;
export import IItem = ns_18.IItem;
export import LocalProvider = ns_20.LocalProvider;
export import CollectionProvider = ns_22.CollectionProvider;
export import ItemProvider = ns_23.ItemProvider;
export import RegistryFactory = ns_24.RegistryFactory;
export import StoreRecords = ns_26.StoreRecords;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };