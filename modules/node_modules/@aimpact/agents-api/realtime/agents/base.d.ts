/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/agents-api/realtime/interfaces/open-ai-events';
import * as __beyond_dep_ns_1 from '@beyond-js/events/events';
import * as __beyond_dep_ns_2 from '@aimpact/agents-api/realtime/interfaces/item';
import * as __beyond_dep_ns_3 from '@aimpact/agents-api/realtime/interfaces/agent-events';
import * as __beyond_dep_ns_4 from '@aimpact/agents-api/realtime/channel';
// conversation\index.ts
declare namespace ns_0 {
  import IConversationCreatedServerEvent = __beyond_dep_ns_0.IConversationCreatedServerEvent;
  import IInputAudioBufferSpeechStartedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStartedServerEvent;
  import IInputAudioBufferSpeechStoppedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStoppedServerEvent;
  import BaseRealtimeAgent = ns_16.BaseRealtimeAgent;
  import Items = ns_8.Items;
  import ConversationResponses = ns_11.ConversationResponses;
  import Speech = ns_13.Speech;
  export class Conversation {
    #private;
    get id(): string;
    get agent(): BaseRealtimeAgent;
    get speech(): Speech;
    get items(): Items;
    get responses(): ConversationResponses;
    constructor(agent: BaseRealtimeAgent);
    listen(chunk: Int16Array): void;
    log(...args: any[]): void;
    onCreated(event: IConversationCreatedServerEvent): void;
    onSpeechStarted(event: IInputAudioBufferSpeechStartedServerEvent): void;
    onSpeechStopped(event: IInputAudioBufferSpeechStoppedServerEvent, audio: Int16Array): void;
  }
}


// conversation\item\audio.ts
declare namespace ns_1 {
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IConversationItemTruncatedServerEvent = __beyond_dep_ns_0.IConversationItemTruncatedServerEvent;
  import IResponseAudioDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioDeltaServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationItemAudio extends Events {
    #private;
    get frequency(): number;
    get value(): Int16Array;
    constructor(frequency?: number);
    truncated(event: IConversationItemTruncatedServerEvent): void;
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * @param event
     */
    created(event: IConversationItemCreatedServerEvent): void;
    /**
     * When a new content part is added to an assistant message item during response generation.
     * @param event
     */
    contentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    audioDelta(event: IResponseAudioDeltaServerEvent): void;
  }
}


// conversation\item\content.ts
declare namespace ns_2 {
  import IConversationInputAudioTranscriptionCompletedServerEvent = __beyond_dep_ns_0.IConversationInputAudioTranscriptionCompletedServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import IResponseAudioTranscriptDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioTranscriptDeltaServerEvent;
  import IResponseAudioDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioDeltaServerEvent;
  import IResponseTextDeltaServerEvent = __beyond_dep_ns_0.IResponseTextDeltaServerEvent;
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IResponseOutputItemDoneServerEvent = __beyond_dep_ns_0.IResponseOutputItemDoneServerEvent;
  import ConversationItemTranscript = ns_7.ConversationItemTranscript;
  import ConversationItemAudio = ns_1.ConversationItemAudio;
  import ConversationItemText = ns_5.ConversationItemText;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationItemContent extends Events {
    #private;
    get status(): "completed" | "in_progress" | "incomplete" | "empty";
    get text(): ConversationItemText;
    get audio(): ConversationItemAudio;
    get transcript(): ConversationItemTranscript;
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * @param event
     */
    created(event: IConversationItemCreatedServerEvent): void;
    /**
     * When a new content part is added to an assistant message item during response generation.
     * @param event
     */
    contentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    audioDelta(event: IResponseAudioDeltaServerEvent): void;
    textDelta(event: IResponseTextDeltaServerEvent): void;
    audioTranscriptDelta(event: IResponseAudioTranscriptDeltaServerEvent): void;
    transcriptionCompleted(event: IConversationInputAudioTranscriptionCompletedServerEvent): void;
    done(event: IResponseOutputItemDoneServerEvent): void;
  }
}


// conversation\item\index.ts
declare namespace ns_3 {
  import ConversationResponse = ns_10.ConversationResponse;
  import IConversationInputAudioTranscriptionCompletedServerEvent = __beyond_dep_ns_0.IConversationInputAudioTranscriptionCompletedServerEvent;
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IConversationItemTruncatedServerEvent = __beyond_dep_ns_0.IConversationItemTruncatedServerEvent;
  import IInputAudioBufferSpeechStartedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStartedServerEvent;
  import IInputAudioBufferSpeechStoppedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStoppedServerEvent;
  import IResponseOutputItemAddedServerEvent = __beyond_dep_ns_0.IResponseOutputItemAddedServerEvent;
  import IResponseOutputItemDoneServerEvent = __beyond_dep_ns_0.IResponseOutputItemDoneServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import IResponseAudioTranscriptDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioTranscriptDeltaServerEvent;
  import IResponseAudioDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioDeltaServerEvent;
  import IResponseTextDeltaServerEvent = __beyond_dep_ns_0.IResponseTextDeltaServerEvent;
  import IResponseFunctionCallArgumentsDeltaServerEvent = __beyond_dep_ns_0.IResponseFunctionCallArgumentsDeltaServerEvent;
  import ItemType = __beyond_dep_ns_2.ItemType;
  import MessageSenderType = __beyond_dep_ns_2.MessageSenderType;
  import ItemStatusType = __beyond_dep_ns_2.ItemStatusType;
  import ConversationItemTool = ns_6.ConversationItemTool;
  import ConversationItemAudio = ns_1.ConversationItemAudio;
  import ConversationItemTranscript = ns_7.ConversationItemTranscript;
  import ConversationItemContent = ns_2.ConversationItemContent;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationItem extends Events {
    #private;
    get id(): string;
    get type(): ItemType;
    get role(): MessageSenderType;
    get audio(): ConversationItemAudio;
    get content(): ConversationItemContent;
    get transcript(): ConversationItemTranscript;
    get tool(): ConversationItemTool;
    get output(): string;
    get status(): ItemStatusType;
    get response(): ConversationResponse;
    constructor(id: string);
    /**
     * When a new Item is created during Response generation.
     *
     * @param response
     * @param event
     */
    added(response: ConversationResponse, event: IResponseOutputItemAddedServerEvent): void;
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * @param event
     */
    created(event: IConversationItemCreatedServerEvent): void;
    contentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    audioTranscriptDelta(event: IResponseAudioTranscriptDeltaServerEvent): void;
    done(event: IResponseOutputItemDoneServerEvent): void;
    truncated(event: IConversationItemTruncatedServerEvent): void;
    speechStarted(event: IInputAudioBufferSpeechStartedServerEvent): void;
    speechStopped(event: IInputAudioBufferSpeechStoppedServerEvent, audio: Int16Array): void;
    transcriptionCompleted(event: IConversationInputAudioTranscriptionCompletedServerEvent): void;
    audioDelta(event: IResponseAudioDeltaServerEvent): void;
    textDelta(event: IResponseTextDeltaServerEvent): void;
    functionCallArgumentsDelta(event: IResponseFunctionCallArgumentsDeltaServerEvent): void;
  }
}


// conversation\item\speech.ts
declare namespace ns_4 {
  import IInputAudioBufferSpeechStoppedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStoppedServerEvent;
  import ConversationItemAudio = ns_1.ConversationItemAudio;
  export class ConversationItemSpeech {
    #private;
    get start(): number;
    get end(): number;
    get value(): Int16Array;
    constructor(input: ConversationItemAudio, start: number);
    stopped(event: IInputAudioBufferSpeechStoppedServerEvent, audio: Int16Array): void;
  }
}


// conversation\item\text.ts
declare namespace ns_5 {
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import IResponseTextDeltaServerEvent = __beyond_dep_ns_0.IResponseTextDeltaServerEvent;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationItemText extends Events {
    #private;
    get frequency(): number;
    get value(): string;
    constructor(frequency?: number);
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * @param event
     */
    created(event: IConversationItemCreatedServerEvent): void;
    /**
     * When a new content part is added to an assistant message item during response generation.
     * @param event
     */
    contentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    /**
     * Returned when the text value of a "text" content part is updated.
     * @param event
     */
    textDelta(event: IResponseTextDeltaServerEvent): void;
  }
}


// conversation\item\tool.ts
declare namespace ns_6 {
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IResponseFunctionCallArgumentsDeltaServerEvent = __beyond_dep_ns_0.IResponseFunctionCallArgumentsDeltaServerEvent;
  export class ConversationItemTool {
    #private;
    get status(): "completed" | "in_progress";
    get caller(): string;
    get name(): string;
    get arguments(): string;
    get output(): string;
    constructor(data: {
      caller: string;
      name: string;
      arguments: string;
    });
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * @param event
     */
    created(event: IConversationItemCreatedServerEvent): void;
    functionCallArgumentsDelta(event: IResponseFunctionCallArgumentsDeltaServerEvent): void;
  }
}


// conversation\item\transcript.ts
declare namespace ns_7 {
  import IConversationInputAudioTranscriptionCompletedServerEvent = __beyond_dep_ns_0.IConversationInputAudioTranscriptionCompletedServerEvent;
  import IResponseAudioTranscriptDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioTranscriptDeltaServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationItemTranscript extends Events {
    #private;
    get value(): string;
    get status(): "completed" | "in_progress" | "empty";
    clear(): void;
    contentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    completed(event: IConversationInputAudioTranscriptionCompletedServerEvent): void;
    audioTranscriptDelta(event: IResponseAudioTranscriptDeltaServerEvent): void;
  }
}


// conversation\items.ts
declare namespace ns_8 {
  import Conversation = ns_0.Conversation;
  import IConversationItemCreatedServerEvent = __beyond_dep_ns_0.IConversationItemCreatedServerEvent;
  import IConversationItemDeletedServerEvent = __beyond_dep_ns_0.IConversationItemDeletedServerEvent;
  import IConversationItemTruncatedServerEvent = __beyond_dep_ns_0.IConversationItemTruncatedServerEvent;
  import IResponseAudioDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioDeltaServerEvent;
  import IResponseAudioTranscriptDeltaServerEvent = __beyond_dep_ns_0.IResponseAudioTranscriptDeltaServerEvent;
  import IResponseContentPartAddedServerEvent = __beyond_dep_ns_0.IResponseContentPartAddedServerEvent;
  import IResponseFunctionCallArgumentsDeltaServerEvent = __beyond_dep_ns_0.IResponseFunctionCallArgumentsDeltaServerEvent;
  import IResponseOutputItemAddedServerEvent = __beyond_dep_ns_0.IResponseOutputItemAddedServerEvent;
  import IResponseOutputItemDoneServerEvent = __beyond_dep_ns_0.IResponseOutputItemDoneServerEvent;
  import IConversationInputAudioTranscriptionCompletedServerEvent = __beyond_dep_ns_0.IConversationInputAudioTranscriptionCompletedServerEvent;
  import IResponseTextDeltaServerEvent = __beyond_dep_ns_0.IResponseTextDeltaServerEvent;
  import IInputAudioBufferSpeechStartedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStartedServerEvent;
  import IItem = __beyond_dep_ns_2.IItem;
  import ConversationItem = ns_3.ConversationItem;
  import Events = __beyond_dep_ns_1.Events;
  export class Items extends Events {
    #private;
    get items(): ConversationItem[];
    get lookup(): Map<string, ConversationItem>;
    has(id: string): boolean;
    get(id: string): ConversationItem;
    delete(id: string): boolean;
    get errors(): string[];
    log(...args: any[]): void;
    constructor(conversation: Conversation);
    create(item: IItem, previous?: string, eventId?: string): void;
    send(message: {
      text?: string;
      audio?: string;
    }): void;
    speechStarted(event: IInputAudioBufferSpeechStartedServerEvent): void;
    /**
     * When a conversation item is created.
     * There are several scenarios that produce this event:
     *
     * 1. The server is generating a Response, which if successful will produce either one or two Items,
     *    which will be of type message (role assistant) or type function_call.
     *
     * 2. The input audio buffer has been committed, either by the client or the server (in server_vad mode).
     *    The server will take the content of the input audio buffer and add it to a new user message Item.
     *
     * 3. The client has sent a conversation.item.create event to add a new Item to the Conversation.
     *
     * @param event
     */
    onItemCreated(event: IConversationItemCreatedServerEvent): void;
    onItemTruncated(event: IConversationItemTruncatedServerEvent): void;
    onItemDeleted(event: IConversationItemDeletedServerEvent): void;
    onTranscriptionCompleted(event: IConversationInputAudioTranscriptionCompletedServerEvent): void;
    /**
     * When a new Item is created during Response generation.
     *
     * @param event
     * @returns
     */
    onResponseItemAdded(event: IResponseOutputItemAddedServerEvent): void;
    onResponseContentPartAdded(event: IResponseContentPartAddedServerEvent): void;
    onResponseAudioTranscriptDelta(event: IResponseAudioTranscriptDeltaServerEvent): void;
    onResponseAudioDelta(event: IResponseAudioDeltaServerEvent): void;
    onResponseTextDelta(event: IResponseTextDeltaServerEvent): void;
    onResponseFunctionCallArgumentsDelta(event: IResponseFunctionCallArgumentsDeltaServerEvent): void;
    onResponseItemDone(event: IResponseOutputItemDoneServerEvent): void;
  }
}


// conversation\progress.ts
declare namespace ns_9 {
  export class AgentManagerConversationProgress {}
}


// conversation\response.ts
declare namespace ns_10 {
  import Conversation = ns_0.Conversation;
  import IResponseCreatedServerEvent = __beyond_dep_ns_0.IResponseCreatedServerEvent;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationResponse extends Events {
    #private;
    get id(): string;
    get status(): string;
    get usage(): {
      inputTokens: number;
      outputTokens: number;
    };
    constructor(conversation: Conversation);
    created(event: IResponseCreatedServerEvent): void;
  }
}


// conversation\responses.ts
declare namespace ns_11 {
  import Conversation = ns_0.Conversation;
  import IResponseCreatedServerEvent = __beyond_dep_ns_0.IResponseCreatedServerEvent;
  import ConversationResponse = ns_10.ConversationResponse;
  import Events = __beyond_dep_ns_1.Events;
  export class ConversationResponses extends Events {
    #private;
    get lookup(): Map<string, ConversationResponse>;
    has(id: string): boolean;
    get(id: string): ConversationResponse;
    delete(id: string): boolean;
    constructor(conversation: Conversation);
    create(): boolean;
    created(event: IResponseCreatedServerEvent): void;
  }
}


// conversation\speech\current.ts
declare namespace ns_12 {
  import Conversation = ns_0.Conversation;
  export class CurrentUserSpeech {
    #private;
    constructor(conversation: Conversation);
    commit(): void;
    append(chunk: Int16Array): void;
  }
}


// conversation\speech\index.ts
declare namespace ns_13 {
  import Conversation = ns_0.Conversation;
  import IInputAudioBufferSpeechStartedServerEvent = __beyond_dep_ns_0.IInputAudioBufferSpeechStartedServerEvent;
  export class Speech {
    #private;
    constructor(conversation: Conversation);
    append(chunk: Int16Array): void;
    flush(): void;
    commit(): void;
    onStarted(event: IInputAudioBufferSpeechStartedServerEvent): void;
  }
}


// conversation\speech\storage.ts
declare namespace ns_14 {
  import Conversation = ns_0.Conversation;
  export class SpeechStorage {
    #private;
    constructor(conversation: Conversation);
    append(chunk: Int16Array): void;
    flush(): void;
    close(): void;
  }
}


// conversation\system.ts
declare namespace ns_15 {
  export class AgentSystem {}
}


// index.ts
declare namespace ns_16 {
  import AgentEventName = __beyond_dep_ns_3.AgentEventName;
  import ISessionSettings = ns_17.ISessionSettings;
  import AgentSession = ns_17.AgentSession;
  import Conversation = ns_0.Conversation;
  import Events = __beyond_dep_ns_1.Events;
  export interface IVoiceAudioDetection {
    type: 'server_vad';
    threshold: number;
    prefix_padding_ms: number;
    silence_duration_ms: number;
  }
  export class BaseRealtimeAgent extends Events {
    #private;
    get vad(): IVoiceAudioDetection;
    set vad(value: IVoiceAudioDetection);
    get session(): AgentSession;
    get manager(): Conversation;
    get status(): AgentStatusType;
    constructor(settings: ISessionSettings);
    triger(event: AgentEventName, ...data: any[]): any;
    connect(): Promise<boolean>;
    close(): Promise<void>;
  }
}


// session.ts
declare namespace ns_17 {
  import ChannelStatusType = __beyond_dep_ns_4.ChannelStatusType;
  import Channel = __beyond_dep_ns_4.Channel;
  import ISessionConfig = __beyond_dep_ns_0.ISessionConfig;
  import Events = __beyond_dep_ns_1.Events;
  import BaseRealtimeAgent = ns_16.BaseRealtimeAgent;
  export interface ISessionSettings {
    key: string;
  }
  export type AgentStatusType = ChannelStatusType | 'created';
  export class AgentSession extends Events {
    #private;
    get channel(): Channel;
    get error(): Error;
    get created(): boolean;
    get status(): AgentStatusType;
    constructor(agent: BaseRealtimeAgent, settings: ISessionSettings);
    /**
     * Connect with the server
     *
     * Take care that the session status is 'connected' after the 'session.created' event is received,
     * not when the socket is connected.
     */
    connect(): Promise<boolean>;
    send(event: string, data?: Record<string, any>): boolean;
    destroy(): void;
    update(value: Partial<ISessionConfig>): void;
    close(): Promise<void>;
  }
}


export import IVoiceAudioDetection = ns_16.IVoiceAudioDetection;
export import BaseRealtimeAgent = ns_16.BaseRealtimeAgent;
export import ISessionSettings = ns_17.ISessionSettings;
export import AgentStatusType = ns_17.AgentStatusType;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };