/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@beyond-js/kernel/core';
import * as __beyond_dep_ns_1 from '@beyond-js/events/events';
// chunks.ts
declare namespace ns_0 {
  export interface IChunksConfig {
    size: number;
  }
  export class RecorderChunks {
    #private;
    constructor(config?: IChunksConfig);
    process({
      raw,
      mono
    }: {
      raw: ArrayBuffer;
      mono: ArrayBuffer;
    }): {
      raw: ArrayBuffer;
      mono: ArrayBuffer;
    };
    pause(): void;
  }
}


// device.ts
declare namespace ns_1 {
  import IRecorderConfig = ns_4.IRecorderConfig;
  import Recorder = ns_4.Recorder;
  export interface DeviceInfo extends MediaDeviceInfo {
    default?: boolean;
  }
  export interface IDevice {
    get id(): string;
    get label(): string;
    get default(): boolean;
    get recorder(): Recorder;
    record(config: IRecorderConfig): Promise<void>;
    pause(): Promise<void>;
    stop(): Promise<void>;
  }
  export class Device implements IDevice {
    #private;
    get id(): string;
    get label(): string;
    get groupId(): string;
    get default(): boolean;
    get recorder(): Recorder;
    constructor(device: DeviceInfo);
    record(config: IRecorderConfig): Promise<void>;
    pause(): Promise<void>;
    stop(): Promise<void>;
  }
}


// index.ts
declare namespace ns_2 {
  import Device = ns_1.Device;
  export const devices: {
    "__#52966@#available": boolean;
    readonly available: boolean;
    readonly default: Device;
    prepare(): Promise<boolean>;
    clear(): void;
    delete(key: string): boolean;
    forEach(callbackfn: (value: Device, key: string, map: Map<string, Device>) => void, thisArg?: any): void;
    get(key: string): Device;
    has(key: string): boolean;
    set(key: string, value: Device): any;
    readonly size: number;
    entries(): IterableIterator<[string, Device]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<Device>;
    [Symbol.iterator](): IterableIterator<[string, Device]>;
    readonly [Symbol.toStringTag]: string;
  };
}


// permission.ts
declare namespace ns_3 {
  import PendingPromise = __beyond_dep_ns_0.PendingPromise;
  export type IPermissionState = 'granted' | 'unknown' | 'denied' | 'prompt';
  export const permissions: {
    "__#52965@#ready": PendingPromise<void>;
    readonly ready: PendingPromise<void>;
    "__#52965@#permission"?: PermissionStatus;
    "__#52965@#state": IPermissionState;
    readonly state: IPermissionState;
    "__#52965@#error": Error;
    readonly error: Error;
    "__#52965@#set"(state: IPermissionState): void;
    /**
     * Not available in Safari
     */
    "__#52965@#onchange"(status: PermissionStatus): void;
    request(): Promise<void>;
    release(): void;
    "__#22385@#private": any;
    readonly destroyed: boolean;
    on(event: string, listener: __beyond_dep_ns_1.ns_1.ListenerFunction, priority?: number): any;
    bind: (event: string, listener: __beyond_dep_ns_1.ns_1.ListenerFunction, priority?: number) => any;
    off(event: string, listener: __beyond_dep_ns_1.ns_1.ListenerFunction, force?: number): any;
    unbind: (event: string, listener: __beyond_dep_ns_1.ns_1.ListenerFunction, force?: number) => any;
    trigger(event: __beyond_dep_ns_1.ns_1.Trigger, ...rest: any): any;
    destroy(): void;
  };
}


// recorder.ts
declare namespace ns_4 {
  import Device = ns_1.Device;
  import Events = __beyond_dep_ns_1.Events;
  import PendingPromise = __beyond_dep_ns_0.PendingPromise;
  import IChunksConfig = ns_0.IChunksConfig;
  export interface IRecorderConfig {
    samplerate?: number;
    debug: boolean;
    chunks?: IChunksConfig;
  }
  type IStatus = 'starting' | 'recording' | 'pausing' | 'paused' | 'stopping' | 'stopped' | 'error';
  /**
   * Records live stream of user audio as PCM16 "audio/wav" data
   */
  export class Recorder extends Events {
    #private;
    get device(): Device;
    get config(): IRecorderConfig;
    get status(): IStatus;
    get error(): Error;
    get ready(): PendingPromise<void>;
    constructor(device: Device, config: IRecorderConfig);
    record(): Promise<boolean>;
    pause(): Promise<void>;
    stop(): Promise<void>;
  }
  export {};
}


export import IDevice = ns_1.IDevice;
export import devices = ns_2.devices;
export import IRecorderConfig = ns_4.IRecorderConfig;
export import Recorder = ns_4.Recorder;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };