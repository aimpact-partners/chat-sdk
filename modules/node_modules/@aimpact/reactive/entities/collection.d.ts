/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/reactive/entities/item';
import * as __beyond_dep_ns_1 from '@aimpact/reactive/model';
// index.ts
declare namespace ns_0 {
  import ItemId = __beyond_dep_ns_0.ItemId;
  import IEntityProvider = __beyond_dep_ns_0.IEntityProvider;
  import ReactiveModel = __beyond_dep_ns_1.ReactiveModel;
  import ICollectionOptions = ns_1.ICollectionOptions;
  import ILoadSpecs = ns_1.ILoadSpecs;
  export class Collection<T, P extends IEntityProvider = IEntityProvider> extends ReactiveModel<Collection<T, P>> {
    #private;
    get entity(): string;
    get provider(): P;
    static isCollection: boolean;
    get Item(): ICollectionOptions<T, P>['item'];
    get map(): Map<ItemId, T>;
    get items(): T[];
    constructor({
      entity,
      provider,
      item
    }: ICollectionOptions<T, P>);
    /**
     * Loads and processes data from an external source via the `DataProvider`.
     * This method uses the configured `provider` to fetch data and apply the specified filters.
     * Filtering parameters are defined in the `args` argument, and the specific filtering logic
     * is implemented by the `DataProvider`.
     *
     * ### Parameters:
     * - `args.where` (optional): Object defining search filters with the following structure:
     *   - `{ property: { operator: value } }`
     *   - Supported operators include:
     *     - `equals`: Exact match with the property value.
     *     - `not`: Value different from the specified value.
     *     - `in`: The property value matches one of the values in the array.
     *     - `notIn`: The property value does not match any of the values in the array.
     *     - `contains`: The property value contains the specified substring.
     *     - `startsWith`: The property value starts with the specified substring.
     *     - `endsWith`: The property value ends with the specified substring.
     *     - `gt` (greater than): The property value is greater than the specified value.
     *     - `gte` (greater than or equal): The property value is greater than or equal to the specified value.
     *     - `lt` (less than): The property value is less than the specified value.
     *     - `lte` (less than or equal): The property value is less than or equal to the specified value.
     *
     * - `args.orderBy` (optional): Object to define the sorting of results. Example:
     *   - `{ property: "asc" | "desc" }` where `"asc"` is ascending order and `"desc"` is descending order.
     *
     * - `args.skip` and `args.take` (optional): Parameters for in-memory pagination.
     *   - `skip`: Number of items to skip from the beginning.
     *   - `take`: Number of items to load after skipping the defined number in `skip`.
     *
     * ### Exceptions:
     * - Throws an error if the `DataProvider` is not defined or does not implement the `load` method.
     * - Throws an error if `DataProvider.load()` does not return an array.
     *
     * @param {Object} args - Object containing filtering and configuration parameters.
     * @returns {Promise<void>} - A promise that resolves when data loading and processing are complete.
     * @throws {Error} - If data cannot be loaded or processed.
     */
    load(args?: ILoadSpecs<T>): Promise<T[]>;
    protected setItems(data: any, clear?: boolean): void;
    /**
     * Validates a new registry against the collection's filters and, if it matches,
     * creates a new item with the registry data and adds it to the data map.
     *
     * @param {object} registry - The new registry data to be checked and potentially added.
     */
    onNewRegistry(registry: Record<string, any>): void;
    onRegistryDeleted(registry: any): void;
    /**
     * Validates if a registry matches the stored filters, including support for AND and OR logical operators.
     * The #filters object contains filtering criteria that are evaluated here.
     *
     * @param {object} registry - The data of the registry to be checked.
     * @returns {boolean} - Returns true if the registry matches all filter criteria; otherwise, false.
     */
    private matchesFilters;
  }
}


// types.ts
declare namespace ns_1 {
  import IEntityProvider = __beyond_dep_ns_0.IEntityProvider;
  export interface ICollectionProviderResponse<T> {
    status: number;
    data?: T;
    error?: string;
    errors?: Array<{
      field: string;
      message: string;
    }>;
  }
  export interface ICollectionProvider {
    load(specs?: any): Promise<any>;
    list(specs?: any): Promise<any>;
    publish?(data: any): Promise<any>;
    remove?(specs?: any): Promise<any>;
  }
  export interface ICollectionOptions<T, P extends Partial<IEntityProvider>> {
    entity: string;
    provider?: new (parent: any) => any;
    item: new (...args: any) => T;
  }
  /**
   * Interface defining the specifications for data loading, filtering, sorting, and pagination.
   */
  export interface ILoadSpecs<T> {
    /**
     * Filters to apply when loading data.
     * Each filter can be a property of the data item with various operators.
     */
    where?: { [K in keyof T]?: {
      equals?: T[K];
      not?: T[K];
      in?: T[K][];
      notIn?: T[K][];
      contains?: string;
      startsWith?: string;
      endsWith?: string;
      gt?: T[K];
      gte?: T[K];
      lt?: T[K];
      lte?: T[K];
    } };
    /**
     * Specifies the order in which results should be returned.
     * Example: { property: "asc" | "desc" }
     */
    orderBy?: { [K in keyof T]?: 'asc' | 'desc' };
    /**
     * Number of items to skip from the beginning of the result set (for pagination).
     */
    offset?: number;
    /**
     * Maximum number of items to load after applying the offset (for pagination).
     */
    limit?: number;
  }
}


export import Collection = ns_0.Collection;
export import ICollectionProvider = ns_1.ICollectionProvider;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };