/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/reactive/model';
// index.ts
declare namespace ns_0 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import SetPropertiesResult = __beyond_dep_ns_0.SetPropertiesResult;
  import Registry = ns_2.Registry;
  import IEntityProvider = ns_4.IEntityProvider;
  import IItem = ns_4.IItem;
  import IItemProps = ns_4.IItemProps;
  export class Item<T extends IItem, P extends IEntityProvider = IEntityProvider> extends ReactiveModel<T> {
    #private;
    get entity(): string;
    get __registryState(): "draft" | "published" | "deleted";
    get fetched(): boolean;
    get found(): boolean;
    protected _provider: P;
    get provider(): P;
    get registry(): Registry;
    get __instanceId(): any;
    get draft(): boolean;
    deleted: boolean;
    constructor({
      entity,
      provider,
      properties,
      ...args
    }?: Partial<IItemProps<T, P>>);
    /**
     *
     * @param param0
     */
    protected initialize({
      ...args
    }: {
      [x: string]: any;
    }): void;
    set(values: any): SetPropertiesResult;
    onSet(): void;
    protected _load(args: any): void;
    load(args?: any): Promise<any>;
    publish(data?: any): Promise<any>;
    delete(id: any): Promise<any>;
  }
}


// registry\factory.ts
declare namespace ns_1 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import Registry = ns_2.Registry;
  import RegistryId = ns_3.RegistryId;
  /**
   * Factory for managing multiple registry instances.
   */
  export class RegistryFactory<T> extends ReactiveModel<RegistryFactory<T>> {
    #private;
    items: Map<RegistryId, Registry>;
    constructor(name: string, properties: any);
    getItem(id: RegistryId, data: any): Registry;
    static getInstance<T>(entity: string, data?: any): RegistryFactory<T>;
  }
}


// registry\index.ts
declare namespace ns_2 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  export class Registry extends ReactiveModel<Registry> {
    #private;
    get state(): "draft" | "published" | "deleted";
    get draft(): boolean;
    set draft(value: boolean);
    get id(): any;
    get instanceId(): any;
    get values(): any;
    get deleted(): boolean;
    set deleted(value: boolean);
    constructor(entity: any, {
      properties,
      ...data
    }?: {
      id: any;
      properties: any[];
      instanceId: any;
    });
    private updateValue;
    setValues(data: any, published?: boolean): boolean;
    getValues(): any;
  }
}


// registry\types\index.ts
declare namespace ns_3 {
  export type RegistryId = string | number;
  export type ReactiveProperty<T> = keyof T | {
    name: keyof T;
  };
  export type RegistryData<T> = {
    id?: string | number;
    instanceId?: string;
    properties: ReactiveProperty<T>[];
  };
}


// types.ts
declare namespace ns_4 {
  export interface IItem {
    id: string | number;
  }
  export type ItemId = string | number;
  export type ReactiveProperty<T> = keyof T | {
    name: keyof T;
  };
  export interface IItemProps<T, P extends IEntityProvider> {
    id?: ItemId;
    provider: new (parent: any) => P;
    entity: string;
    properties: any;
  }
  export interface IItemProviderResponse<T> {
    status: number;
    data?: T;
    error?: string;
    errors?: Array<{
      field: string;
      message: string;
    }>;
  }
  export interface IEntityProvider {
    load?(specs?: any): Promise<any>;
    list?(specs?: any): Promise<any>;
    publish?(data: any): Promise<any>;
    remove?(specs: any): Promise<any>;
    delete?(specs?: any): Promise<any>;
  }
  export type IRecordProps<T> = {
    id: ItemId;
    properties: Array<ReactiveProperty<T>>;
    [key: string]: any;
  };
}


export import Item = ns_0.Item;
export import RegistryFactory = ns_1.RegistryFactory;
export import IItem = ns_4.IItem;
export import ItemId = ns_4.ItemId;
export import IItemProps = ns_4.IItemProps;
export import IEntityProvider = ns_4.IEntityProvider;
export import IRecordProps = ns_4.IRecordProps;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };