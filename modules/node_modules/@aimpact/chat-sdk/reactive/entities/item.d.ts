/************
Processor: ts
************/

import * as __beyond_dep_ns_0 from '@aimpact/chat-sdk/reactive/model';
// index.ts
declare namespace ns_0 {
  import RegistryData = ns_3.RegistryData;
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import SetPropertiesResult = __beyond_dep_ns_0.SetPropertiesResult;
  import IItemProps = ns_4.IItemProps;
  import IEntityProvider = ns_4.IEntityProvider;
  import Registry = ns_2.Registry;
  export class Item<P extends IEntityProvider = IEntityProvider> extends ReactiveModel<RegistryData> {
    #private;
    id: RegistryData['id'];
    get entity(): string;
    get fetched(): boolean;
    get found(): boolean;
    protected _provider: P;
    get provider(): P;
    get registry(): Registry;
    get draft(): boolean;
    constructor({
      entity,
      provider,
      properties,
      ...args
    }?: Partial<IItemProps<P>>);
    /**
     *
     * @param param0
     */
    protected initialize({
      ...args
    }: {
      [x: string]: any;
    }): void;
    private registryListener;
    set(values: any): SetPropertiesResult;
    onSet(): void;
    protected _load(args: any): void;
    load?(args?: any): Promise<any>;
    publish?(data?: any): Promise<any>;
    delete?(id: any): Promise<any>;
  }
}


// registry\factory.ts
declare namespace ns_1 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import RegistryData = ns_3.RegistryData;
  import RegistryId = ns_3.RegistryId;
  import Registry = ns_2.Registry;
  import IRecordProps = ns_4.IRecordProps;
  /**
   * Factory for managing multiple registry instances.
   */
  export class RegistryFactory<T = IRecordProps> extends ReactiveModel<RegistryFactory<T>> {
    #private;
    items: Map<RegistryId, Registry>;
    constructor(name: string, properties: any);
    get(id: RegistryId, data: any): Registry;
    static getInstance<U extends RegistryData>(entity: string, data?: any): RegistryFactory<U>;
  }
}


// registry\index.ts
declare namespace ns_2 {
  import ReactiveModel = __beyond_dep_ns_0.ReactiveModel;
  import ModelProperties = __beyond_dep_ns_0.ModelProperties;
  import RegistryData = ns_3.RegistryData;
  import IRecordProps = ns_4.IRecordProps;
  export class Registry extends ReactiveModel<IRecordProps> {
    #private;
    get draft(): boolean;
    set draft(value: boolean);
    get id(): string | number;
    get instanceId(): string | number;
    get values(): RegistryData;
    get deleted(): boolean;
    set deleted(value: boolean);
    constructor(entity: any, {
      properties,
      ...data
    }?: Partial<RegistryData>);
    private updateValue;
    setValues(data: Partial<RegistryData>): boolean;
    getValues(): ModelProperties<RegistryData>;
  }
}


// registry\types\index.ts
declare namespace ns_3 {
  export type RegistryData = {
    id?: string | number;
    instanceId?: string;
    properties: any[];
  };
  export type RegistryId = RegistryData['id'] | RegistryData['instanceId'];
  export type RegistryDataValue = Omit<RegistryData, 'properties'>;
}


// types.ts
declare namespace ns_4 {
  import Item = ns_0.Item;
  export type ItemId = string | number;
  export interface IItemProps<P extends IEntityProvider> {
    id?: ItemId;
    provider: new (parent: Item) => P;
    entity: string;
    properties: any;
  }
  export interface IItemProviderResponse<T> {
    status: number;
    data?: T;
    error?: string;
    errors?: Array<{
      field: string;
      message: string;
    }>;
  }
  export interface IEntityProvider {
    load?(specs?: any): Promise<any>;
    list?(specs?: any): Promise<any>;
    publish?(data: any): Promise<any>;
    remove?(specs: any): Promise<any>;
    delete?(specs?: any): Promise<any>;
  }
  export type IRecordProps = {
    id: ItemId;
    properties: any;
    [key: string]: any;
  };
}


export import Item = ns_0.Item;
export import RegistryFactory = ns_1.RegistryFactory;
export import ItemId = ns_4.ItemId;
export import IItemProps = ns_4.IItemProps;
export import IEntityProvider = ns_4.IEntityProvider;
export import IRecordProps = ns_4.IRecordProps;

export declare const hmr: {on: (event: string, listener: any) => void, off: (event: string, listener: any) => void };